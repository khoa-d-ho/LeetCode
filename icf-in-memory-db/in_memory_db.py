# -*- coding: utf-8 -*-
"""in_memory_DB.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yYqn_9GHF-vxygec_L1hPuSAsTwDTTht
"""

class Database:
    def __init__(self):
        """
        Initializes the main database and the backup storage.
        - self.db will store the current state of the database.
        - self.backups will store snapshots for the backup/restore functionality.
        """
        self.db = {}
        self.backups = {}


    # --- LEVEL 1 --- #

    def set(self, key: str, field: str, value: str) -> None:
        if key not in self.db:
            self.db[key] = {}
        self.db[key][field] = value

    def get(self, key: str, field:str) -> str | None:
        # get value of key, return None if key does not exist
        return self.db[key].get(field)

    def delete(self, key: str, field: str) -> bool:
        if key not in self.db or field not in self.db[key]:
            return False

        del self.db[key][field] # self.db[key].pop(field)

        # clean empty brackets
        if not self.db[key]:
            del self.db[key]

        return True

    # --- LEVEL 2 --- #
    # {"A": {"BC": "E", "BD": "F", "C": "G"}}
    # scan(A): ["BC(E)", "BD(F)", "C(G)"]
    # scan_by_prefix(A, B): ["BC(E)", "BD(F)"]

    def scan(self, key: str) -> list[str]:
        if key not in self.db:
            return []
        res = []
        for field in sorted(self.db[key].keys()):
            value = self.db[key][field]
            res.append(f'{field}({value})')
        return res

        # return [f"{field}({self.db[key][field]})" for field in sorted(self.db[key].keys())]

    def scan_by_prefix(self, key: str, prefix: str) -> list[str]:
        if key not in self.db:
            return []
        res = []
        for field in sorted(self.db[key].keys()):
            if field.startswith(prefix):
                value = self.db[key][field]
                res.append(f'{field}({value})')
        return res

    # --- LEVEL 3 --- #
    # self.db[key][field] = {"value": value, "timestamp": timestamp, "ttl": ttl}

    def set_helper(self, key, field, value, timestamp, ttl):
        if key not in self.db:
            self.db[key] = {}
        self.db[key][field] = {
            "value": value,
            "timestamp": timestamp,
            "ttl": ttl
        }

    def live_helper(self, field_info, timestamp):
        # if field_info["ttl"] == None:
        #     ttl = float('inf')
        # else: ttl = field_info["ttl"]
        ttl = float('inf') if field_info["ttl"] == None else field_info["ttl"]

        return field_info["timestamp"] <= timestamp < field_info["timestamp"] + ttl

    def set_at(self, key: str, field: str, value: str, timestamp: int) -> None:
        self.set_helper(key, field, value, timestamp, None)

    def set_at_with_ttl(self, key: str, field: str, value: str, timestamp: int, ttl: int) -> None:
        self.set_helper(key, field, value, timestamp, ttl)

    def delete_at(self, key: str, field: str, timestamp: int) -> bool:
        # only delete if still exist
        if key not in self.db or field not in self.db[key] or not self.live_helper(self.db[key][field], timestamp):
            return False

        del self.db[key][field]  # self.db[key].pop(field)

        # clean empty brackets
        if not self.db[key]:
            del self.db[key]

        return True

    def get_at(self, key: str, field: str, timestamp: int) -> str | None:
        if key not in self.db or field not in self.db[key] or not self.live_helper(self.db[key][field], timestamp):
            return None
        return self.db[key][field]["value"]

    def scan_at(self, key: str, timestamp: int) -> list[str]:
        if key not in self.db:
            return []
        res = []
        for field, info in sorted(self.db[key].items()):
            if self.live_helper(info, timestamp):
                res.append(f"{field}({info['value']})")
        return res

        # return [f"{field}({info['value']})" for field, info in sorted(self.db[key].items()) if self._valid_time(info, timestamp)]

    def scan_by_prefix_at(self, key: str, prefix: str, timestamp: int) -> list[str]:
        if key not in self.db:
            return []
        res = []
        for field, info in sorted(self.db[key].items()):
            if self.live_helper(info, timestamp) and field.startswith(prefix):
                res.append(f"{field}({info['value']})")
        return res

    # --- LEVEL 4 --- #

    def backup(self, timestamp: int) -> int:
        """
        1.  Initializes an empty dictionary for the new backup and a counter for live records.
        2.  Loops through each record (key) and its fields in the current database.
        3.  For each field, it checks if it's "live" at the backup's timestamp using the
            live_helper.
        4.  If a field is live, its remaining lifespan (TTL) is calculated. This remaining
            TTL, along with its value, is added to a temporary dictionary for the record's
            live fields.
        5.  After checking all fields in a record, if at least one was live, the record
            counter is incremented, and the temporary dictionary of live fields is
            added to the main backup snapshot.
        6.  Finally, the completed snapshot is stored, and the total count of live
            records is returned.
        """
        records_count = 0
        backup_db = {}

        for key, fields in self.db.items():
            is_record_live = False
            live_fields_for_backup = {}

            for field, data in fields.items():
                if self.live_helper(data, timestamp):
                    is_record_live = True
                    remaining_ttl = None

                    if data["ttl"] is not None:
                        elapsed_time = timestamp - data["timestamp"]
                        remaining_ttl = data["ttl"] - elapsed_time

                    live_fields_for_backup[field] = {
                        "value": data["value"],
                        "timestamp": data["timestamp"],
                        "ttl": remaining_ttl
                    }

            if is_record_live:
                records_count += 1
                backup_db[key] = live_fields_for_backup

        self.backups[timestamp] = backup_db
        return records_count

    def restore(self, timestamp: int, timestamp_to_restore: int) -> None:
        """
        1.  Searches through all saved backups to find the timestamp of the most
            recent one created at or before the `timestamp_to_restore`.
        2.  If no suitable backup is found, it clears the database to an empty state
            and stops.
        3.  If a backup is found, the current database is wiped clean.
        4.  It then loops through the records and fields in the chosen backup snapshot.
        5.  As each field is restored, its timeline is shifted to the "present":
            - Its new "start time" is set to the current `timestamp`.
            - Its new "lifespan" (TTL) is set to the remaining TTL that was
            pre-calculated and saved in the backup.
        """
        valid_times = [t for t in self.backups if t <= timestamp_to_restore]
        if not valid_times:
            self.db.clear()
            return

        last_backup_time = max(valid_times)
        restored_backup = self.backups[last_backup_time]
        self.db.clear()

        for key, fields in restored_backup.items():
            self.db[key] = {}
            for field, data in fields.items():
                self.db[key][field] = {
                    "value": data["value"],
                    "timestamp": timestamp,
                    "ttl": data["ttl"]
            }

# --- Example Usage --- #
if __name__ == "__main__":
    # You can test your implementation here
    db = Database()

    # Level 1 Example
    print("--- Level 1 ---")
    db.set("A", "B", "E")
    db.set("A", "C", "F")
    print(f"get('A', 'B'): {db.get('A', 'B')}")      # Expected: "E"
    print(f"delete('A', 'B'): {db.delete('A', 'B')}")  # Expected: True
    print(f"get('A', 'B'): {db.get('A', 'B')}")      # Expected: None
    print(f"db state: {db.db}")

    # As you implement each level, you can add more tests here.
    # For example:
    print("\n--- Level 2 ---")
    db.set("A", "BC", "E")
    db.set("A", "BD", "F")
    print(f"scan('A'): {db.scan('A')}")               # Expected: ['BC(E)', 'BD(F)', 'C(F)']
    print(f"scan_by_prefix('A', 'B'): {db.scan_by_prefix('A', 'B')}") # Expected: ['BC(E)', 'BD(F)']

    # --- Level 3 --- #
    print("\n--- Level 3 ---")
    db_l3 = Database()
    db_l3.set_at_with_ttl("X", "Y", "Z", timestamp=10, ttl=5) # Expires at t=15
    print(f"get_at('X', 'Y', 14): {db_l3.get_at('X', 'Y', 14)}") # Expected: 'Z'
    print(f"get_at('X', 'Y', 15): {db_l3.get_at('X', 'Y', 15)}") # Expected: None

    db_l3.set_at("A", "D", "E", timestamp=4) # Never expires
    db_l3.set_at_with_ttl("A", "B", "C", timestamp=1, ttl=10) # Expires at t=11
    print(f"scan_at('A', 10): {db_l3.scan_at('A', 10)}") # Expected: ['B(C)', 'D(E)']
    print(f"delete_at('A', 'B', 8): {db_l3.delete_at('A', 'B', 8)}") # Expected: True
    print(f"scan_at('A', 12): {db_l3.scan_at('A', 12)}") # Expected: ['D(E)']

    # --- Level 4 --- #
    print("\n--- Level 4 ---")
    db_l4 = Database()
    db_l4.set_at_with_ttl("A", "B", "C", 1, 10) # Expires at t=11
    print(f"backup(3): {db_l4.backup(3)}") # Expected: 1

    db_l4.set_at("A", "D", "E", 4)
    print(f"backup(5): {db_l4.backup(5)}") # Expected: 1

    db_l4.delete_at("A", "B", 8)
    print(f"backup(9): {db_l4.backup(9)}") # Expected: 1

    print("Restoring to state at t=7 (latest backup is from t=5)...")
    db_l4.restore(10, 7) # Field "B" should be restored and expire at t = 10 + (11 - 5) = 16

    print(f"scan_at('A', 15): {db_l4.scan_at('A', 15)}") # Expected: ['B(C)', 'D(E)']
    print(f"scan_at('A', 16): {db_l4.scan_at('A', 16)}") # Expected: ['D(E)']